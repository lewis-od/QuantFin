<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.1" />
<title>quantfin.volatility API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>quantfin.volatility</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import warnings
import numpy as np
import scipy.special
from scipy.optimize import minimize

def moving_average(R, M):
    &#34;&#34;&#34;Calculates volatility using an M-day moving average.

    Args:
        R (numpy.array): Financial returns data from which to calculate volatility.
        M (int): Number of days to use for the moving average.

    Returns:
        An numpy array of size `(len(R) - M)` containing the calculated
        volatilities.
    &#34;&#34;&#34;
    N = len(R)
    sigma_sq = np.zeros(N - M)
    for i in range(M, N):
        sigma_sq[i - M] = R[i-M:i].std() ** 2

    return sigma_sq


def ewma(R, smoothing=0.98):
    &#34;&#34;&#34;Calculates volatility using an exponentially weighted moving average.

    Args:
        R (numpy.array): Financial returns data from which to calculate volatility.
        smoothing (float): Smoothing parameter (lambda).

    Returns:
        A numpy array of size `len(R)` containing the calculated volatilities.
    &#34;&#34;&#34;
    N = len(R)
    sigma_sq = np.zeros(N)
    for n in range(N):
        vol = np.array([(smoothing ** i) * (R[n-i] ** 2) for i in range(n)]).sum()
        vol *= (1 - smoothing)
        sigma_sq[n] = vol

    return sigma_sq


def garch(R, verbose=False):
    &#34;&#34;&#34;Calculates volatility using the symmetric GARCH(1,1) model.

    The parameters for the model are cauluated using the maximum likelihood
    method. The likelihood function is maximised using scipy.

    This slows down rapidly as R increases in size due to the recursive
    nature of GARCH.

    Args:
        R (numpy.array): Financial returns data from which to calculate
            volatility.
        verbose (bool, optional): Whether or not to print warnings and
            convergence information.

    Returns:
        A tuple `(volatility, params)`, where `volatility` is a numpy array
        of size `len(R)` containing the calculated volatilities, and
        `params = [alpha, beta, omega]` are the calculated values of the model
        parameters.

    Raises:
        RuntimeError: If the optimisation algorithm fails to converge.
    &#34;&#34;&#34;
    N = len(R)

    # sigma^2 using GARCH model
    def sigma_sq(n, alpha, beta, omega):
        prev = 0 if (n == 0) else sigma_sq(n-1, alpha, beta, omega)
        return omega + alpha * R[n-1]**2 + beta * prev

    # Log of likelihood function
    def L(params):
        alpha, beta, omega = params
        value = 0
        for n in range(N):
            sigma_n_sq = sigma_sq(n, alpha, beta, omega)
            value += np.log(sigma_n_sq + (R[n]**2)/sigma_n_sq)
        value *= -0.5
        # Return -L instead of L (minimise -L =&gt; maximise L)
        return -value

    # Constrain alpha and beta to be positive
    # Use def instead of lambdas for speed
    def a_con(x):
        return np.array([x[0]])
    def b_con(x):
        return np.array([x[1]])
    alpha_con = { &#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: a_con }
    beta_con = { &#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: b_con }
    cons = (alpha_con, beta_con)

    # Don&#39;t show warnings unless verbose flag specified
    if not verbose:
        warnings.filterwarnings(&#39;ignore&#39;)

    # Minimise -L to find values of alpha, beta, and omega
    res = minimize(L, [0.5, 0.5, 0.0], constraints=cons,
                   options={ &#39;maxiter&#39;: 500, &#39;disp&#39;: verbose })

    # Turn warnings back on if they were turned off above
    if not verbose:
        warnings.resetwarnings()

    if res.success == False:
        raise RuntimeError(&#34;Unable to fit GARCH(1,1) model: &#34; + res.message)

    # Calculate the volatility using the parameters found by minimize
    params = res.x
    volatility = np.array([sigma_sq(n, params[0], params[1], params[2]) for n in range(N)])

    return (volatility, params)

def garch_asym(R, verbose=False):
    &#34;&#34;&#34;Calculates volatility using the asymmetric GARCH(1,1) model.

    The parameters for the model are cauluated using the maximum likelihood
    method. The likelihood function is maximised using scipy.

    This slows down rapidly as R increases in size due to the recursive
    nature of GARCH. The symmetric GARCH(1,1) model `garch` will be slightly
    faster due to optimising over less parameters.

    Args:
        R (numpy.array): Financial returns data from which to calculate volatility.
        verbose (bool, optional): Whether or not to print warnings and
            convergence information.

    Returns:
        A tuple `(volatility, params)`, where `volatility` is a numpy array
        of size `len(R)` containing the calculated volatilities, and
        `params = [alpha, beta, omega, delta]` are the calculated values of the
        model parameters.

    Raises:
        RuntimeError: If the optimisation algorithm fails to converge.
    &#34;&#34;&#34;
    N = len(R)

    # sigma^2 using asymmetric GARCH model
    def sigma_sq(n, alpha, beta, omega, delta):
        prev = 0 if (n == 0) else sigma_sq(n-1, alpha, beta, omega, delta)
        return omega + alpha * (R[n-1] - delta)**2 + beta * prev

    # Log of likelihood function
    def L(params):
        alpha, beta, omega, delta = params
        value = 0
        for n in range(N):
            sigma_n_sq = sigma_sq(n, alpha, beta, omega, delta)
            value += np.log(sigma_n_sq + (R[n]**2)/sigma_n_sq)
        value *= -0.5
        # Return -L instead of L (minimise -L =&gt; maximise L)
        return -value

    # Constrain alpha, beta, and delta to be positive
    # Use def instead of lambdas for speed
    def a_con(x):
        return np.array([x[0]])
    def b_con(x):
        return np.array([x[1]])
    def d_con(x):
        return np.array([x[3]])

    alpha_con = { &#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: a_con }
    beta_con = { &#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: b_con }
    delta_con = { &#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: d_con }
    cons = (alpha_con, beta_con, delta_con)

    # Don&#39;t show warnings unless verbose flag specified
    if not verbose:
        warnings.filterwarnings(&#39;ignore&#39;)

    # Minimise -L to find values of alpha, beta, and omega
    res = minimize(L, [0.5, 0.5, 0.0, 0.0], constraints=cons,
                   options={ &#39;maxiter&#39;: 500, &#39;disp&#39;: verbose })

    # Turn warnings back on if they were turned off above
    if not verbose:
        warnings.resetwarnings()

    if res.success == False:
        raise RuntimeError(&#34;Unable to fit GARCH(1,1) model: &#34; + res.message)

    # Calculate the volatility using the parameters found by minimize
    params = res.x
    volatility = np.array([sigma_sq(n, params[0], params[1], params[2], params[3]) for n in range(N)])

    return (volatility, params)

def annualise(sigma_sq, N=250):
    &#34;&#34;&#34;Converts volatility into annualised volatility.

    Args:
        sigma_sq (numpy.array): Volatilities calculated at daily (or other
            regular) intervals.
        N (int, optional): Number of trading days (or weeks, etc) in a year.
    &#34;&#34;&#34;
    return np.sqrt(sigma_sq * N)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="quantfin.volatility.annualise"><code class="name flex">
<span>def <span class="ident">annualise</span></span>(<span>sigma_sq, N=250)</span>
</code></dt>
<dd>
<section class="desc"><p>Converts volatility into annualised volatility.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sigma_sq</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>Volatilities calculated at daily (or other
regular) intervals.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of trading days (or weeks, etc) in a year.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def annualise(sigma_sq, N=250):
    &#34;&#34;&#34;Converts volatility into annualised volatility.

    Args:
        sigma_sq (numpy.array): Volatilities calculated at daily (or other
            regular) intervals.
        N (int, optional): Number of trading days (or weeks, etc) in a year.
    &#34;&#34;&#34;
    return np.sqrt(sigma_sq * N)</code></pre>
</details>
</dd>
<dt id="quantfin.volatility.ewma"><code class="name flex">
<span>def <span class="ident">ewma</span></span>(<span>R, smoothing=0.98)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates volatility using an exponentially weighted moving average.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>Financial returns data from which to calculate volatility.</dd>
<dt><strong><code>smoothing</code></strong> :&ensp;<code>float</code></dt>
<dd>Smoothing parameter (lambda).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A numpy array of size <code>len(R)</code> containing the calculated volatilities.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def ewma(R, smoothing=0.98):
    &#34;&#34;&#34;Calculates volatility using an exponentially weighted moving average.

    Args:
        R (numpy.array): Financial returns data from which to calculate volatility.
        smoothing (float): Smoothing parameter (lambda).

    Returns:
        A numpy array of size `len(R)` containing the calculated volatilities.
    &#34;&#34;&#34;
    N = len(R)
    sigma_sq = np.zeros(N)
    for n in range(N):
        vol = np.array([(smoothing ** i) * (R[n-i] ** 2) for i in range(n)]).sum()
        vol *= (1 - smoothing)
        sigma_sq[n] = vol

    return sigma_sq</code></pre>
</details>
</dd>
<dt id="quantfin.volatility.garch"><code class="name flex">
<span>def <span class="ident">garch</span></span>(<span>R, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates volatility using the symmetric GARCH(1,1) model.</p>
<p>The parameters for the model are cauluated using the maximum likelihood
method. The likelihood function is maximised using scipy.</p>
<p>This slows down rapidly as R increases in size due to the recursive
nature of GARCH.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>Financial returns data from which to calculate
volatility.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to print warnings and
convergence information.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple <code>(volatility, params)</code>, where <code>volatility</code> is a numpy array
of size <code>len(R)</code> containing the calculated volatilities, and
<code>params = [alpha, beta, omega]</code> are the calculated values of the model
parameters.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>RuntimeError</code></strong></dt>
<dd>If the optimisation algorithm fails to converge.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def garch(R, verbose=False):
    &#34;&#34;&#34;Calculates volatility using the symmetric GARCH(1,1) model.

    The parameters for the model are cauluated using the maximum likelihood
    method. The likelihood function is maximised using scipy.

    This slows down rapidly as R increases in size due to the recursive
    nature of GARCH.

    Args:
        R (numpy.array): Financial returns data from which to calculate
            volatility.
        verbose (bool, optional): Whether or not to print warnings and
            convergence information.

    Returns:
        A tuple `(volatility, params)`, where `volatility` is a numpy array
        of size `len(R)` containing the calculated volatilities, and
        `params = [alpha, beta, omega]` are the calculated values of the model
        parameters.

    Raises:
        RuntimeError: If the optimisation algorithm fails to converge.
    &#34;&#34;&#34;
    N = len(R)

    # sigma^2 using GARCH model
    def sigma_sq(n, alpha, beta, omega):
        prev = 0 if (n == 0) else sigma_sq(n-1, alpha, beta, omega)
        return omega + alpha * R[n-1]**2 + beta * prev

    # Log of likelihood function
    def L(params):
        alpha, beta, omega = params
        value = 0
        for n in range(N):
            sigma_n_sq = sigma_sq(n, alpha, beta, omega)
            value += np.log(sigma_n_sq + (R[n]**2)/sigma_n_sq)
        value *= -0.5
        # Return -L instead of L (minimise -L =&gt; maximise L)
        return -value

    # Constrain alpha and beta to be positive
    # Use def instead of lambdas for speed
    def a_con(x):
        return np.array([x[0]])
    def b_con(x):
        return np.array([x[1]])
    alpha_con = { &#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: a_con }
    beta_con = { &#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: b_con }
    cons = (alpha_con, beta_con)

    # Don&#39;t show warnings unless verbose flag specified
    if not verbose:
        warnings.filterwarnings(&#39;ignore&#39;)

    # Minimise -L to find values of alpha, beta, and omega
    res = minimize(L, [0.5, 0.5, 0.0], constraints=cons,
                   options={ &#39;maxiter&#39;: 500, &#39;disp&#39;: verbose })

    # Turn warnings back on if they were turned off above
    if not verbose:
        warnings.resetwarnings()

    if res.success == False:
        raise RuntimeError(&#34;Unable to fit GARCH(1,1) model: &#34; + res.message)

    # Calculate the volatility using the parameters found by minimize
    params = res.x
    volatility = np.array([sigma_sq(n, params[0], params[1], params[2]) for n in range(N)])

    return (volatility, params)</code></pre>
</details>
</dd>
<dt id="quantfin.volatility.garch_asym"><code class="name flex">
<span>def <span class="ident">garch_asym</span></span>(<span>R, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates volatility using the asymmetric GARCH(1,1) model.</p>
<p>The parameters for the model are cauluated using the maximum likelihood
method. The likelihood function is maximised using scipy.</p>
<p>This slows down rapidly as R increases in size due to the recursive
nature of GARCH. The symmetric GARCH(1,1) model <a title="quantfin.volatility.garch" href="#quantfin.volatility.garch"><code>garch()</code></a> will be slightly
faster due to optimising over less parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>Financial returns data from which to calculate volatility.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to print warnings and
convergence information.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple <code>(volatility, params)</code>, where <code>volatility</code> is a numpy array
of size <code>len(R)</code> containing the calculated volatilities, and
<code>params = [alpha, beta, omega, delta]</code> are the calculated values of the
model parameters.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>RuntimeError</code></strong></dt>
<dd>If the optimisation algorithm fails to converge.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def garch_asym(R, verbose=False):
    &#34;&#34;&#34;Calculates volatility using the asymmetric GARCH(1,1) model.

    The parameters for the model are cauluated using the maximum likelihood
    method. The likelihood function is maximised using scipy.

    This slows down rapidly as R increases in size due to the recursive
    nature of GARCH. The symmetric GARCH(1,1) model `garch` will be slightly
    faster due to optimising over less parameters.

    Args:
        R (numpy.array): Financial returns data from which to calculate volatility.
        verbose (bool, optional): Whether or not to print warnings and
            convergence information.

    Returns:
        A tuple `(volatility, params)`, where `volatility` is a numpy array
        of size `len(R)` containing the calculated volatilities, and
        `params = [alpha, beta, omega, delta]` are the calculated values of the
        model parameters.

    Raises:
        RuntimeError: If the optimisation algorithm fails to converge.
    &#34;&#34;&#34;
    N = len(R)

    # sigma^2 using asymmetric GARCH model
    def sigma_sq(n, alpha, beta, omega, delta):
        prev = 0 if (n == 0) else sigma_sq(n-1, alpha, beta, omega, delta)
        return omega + alpha * (R[n-1] - delta)**2 + beta * prev

    # Log of likelihood function
    def L(params):
        alpha, beta, omega, delta = params
        value = 0
        for n in range(N):
            sigma_n_sq = sigma_sq(n, alpha, beta, omega, delta)
            value += np.log(sigma_n_sq + (R[n]**2)/sigma_n_sq)
        value *= -0.5
        # Return -L instead of L (minimise -L =&gt; maximise L)
        return -value

    # Constrain alpha, beta, and delta to be positive
    # Use def instead of lambdas for speed
    def a_con(x):
        return np.array([x[0]])
    def b_con(x):
        return np.array([x[1]])
    def d_con(x):
        return np.array([x[3]])

    alpha_con = { &#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: a_con }
    beta_con = { &#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: b_con }
    delta_con = { &#39;type&#39;: &#39;ineq&#39;, &#39;fun&#39;: d_con }
    cons = (alpha_con, beta_con, delta_con)

    # Don&#39;t show warnings unless verbose flag specified
    if not verbose:
        warnings.filterwarnings(&#39;ignore&#39;)

    # Minimise -L to find values of alpha, beta, and omega
    res = minimize(L, [0.5, 0.5, 0.0, 0.0], constraints=cons,
                   options={ &#39;maxiter&#39;: 500, &#39;disp&#39;: verbose })

    # Turn warnings back on if they were turned off above
    if not verbose:
        warnings.resetwarnings()

    if res.success == False:
        raise RuntimeError(&#34;Unable to fit GARCH(1,1) model: &#34; + res.message)

    # Calculate the volatility using the parameters found by minimize
    params = res.x
    volatility = np.array([sigma_sq(n, params[0], params[1], params[2], params[3]) for n in range(N)])

    return (volatility, params)</code></pre>
</details>
</dd>
<dt id="quantfin.volatility.moving_average"><code class="name flex">
<span>def <span class="ident">moving_average</span></span>(<span>R, M)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates volatility using an M-day moving average.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>numpy.array</code></dt>
<dd>Financial returns data from which to calculate volatility.</dd>
<dt><strong><code>M</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of days to use for the moving average.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An numpy array of size <code>(len(R) - M)</code> containing the calculated
volatilities.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def moving_average(R, M):
    &#34;&#34;&#34;Calculates volatility using an M-day moving average.

    Args:
        R (numpy.array): Financial returns data from which to calculate volatility.
        M (int): Number of days to use for the moving average.

    Returns:
        An numpy array of size `(len(R) - M)` containing the calculated
        volatilities.
    &#34;&#34;&#34;
    N = len(R)
    sigma_sq = np.zeros(N - M)
    for i in range(M, N):
        sigma_sq[i - M] = R[i-M:i].std() ** 2

    return sigma_sq</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="quantfin" href="index.html">quantfin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="quantfin.volatility.annualise" href="#quantfin.volatility.annualise">annualise</a></code></li>
<li><code><a title="quantfin.volatility.ewma" href="#quantfin.volatility.ewma">ewma</a></code></li>
<li><code><a title="quantfin.volatility.garch" href="#quantfin.volatility.garch">garch</a></code></li>
<li><code><a title="quantfin.volatility.garch_asym" href="#quantfin.volatility.garch_asym">garch_asym</a></code></li>
<li><code><a title="quantfin.volatility.moving_average" href="#quantfin.volatility.moving_average">moving_average</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>